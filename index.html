<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Пришельцы 2800 - Исправленная версия</title>
    <style>
        body {
            background-color: #0b0c15;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px;
            user-select: none;
        }
        h1 {
            color: #ff0055;
            text-shadow: 0 0 15px #ff0055;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 4px;
            font-size: 1.8rem;
        }
        #game-wrapper {
            position: relative;
            padding: 10px;
            background: #1a1a2e;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            border: 1px solid #333;
        }
        canvas {
            display: block;
            cursor: crosshair;
            background: radial-gradient(circle at 50% 50%, #232338 0%, #0a0a12 100%);
            border-radius: 4px;
        }
        #ui-panel {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            padding: 15px;
            background: #13141f;
            border-top: 2px solid #333;
            border-radius: 0 0 10px 10px;
        }
        .score-box { text-align: center; min-width: 80px; }
        .score-val { font-size: 2em; font-weight: 800; line-height: 1; }
        .label { font-size: 0.7em; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px; opacity: 0.8; }
        .earth { color: #00eaff; text-shadow: 0 0 10px rgba(0, 234, 255, 0.5); }
        .aliens { color: #ff2a2a; text-shadow: 0 0 10px rgba(255, 42, 42, 0.5); }
        
        .turn-indicator { 
            color: #fff; font-size: 1em; margin: 5px 0 15px 0; 
            padding: 5px 20px; border-radius: 20px; background: rgba(255,255,255,0.1); 
        }
        button {
            margin-top: 15px; padding: 10px 25px; background: transparent;
            color: #ffd700; border: 1px solid #ffd700; cursor: pointer;
            font-weight: bold; text-transform: uppercase; transition: 0.3s;
        }
        button:hover { background: #ffd700; color: #000; box-shadow: 0 0 15px #ffd700; }
        
        #rules {
            max-width: 800px; margin-top: 20px; background: rgba(255, 255, 255, 0.05);
            padding: 15px; border-radius: 8px; line-height: 1.5; font-size: 0.85em;
            border-left: 4px solid #ffd700; color: #ccc;
        }
    </style>
</head>
<body>

    <h1>Пришельцы</h1>
    <div class="turn-indicator" id="status">Ход: ПРИШЕЛЬЦЫ</div>

    <div id="game-wrapper">
        <canvas id="board" width="820" height="640"></canvas>
        
        <div id="ui-panel">
            <div class="score-box aliens">
                <div class="label">Пришельцы</div>
                <div class="score-val" id="score-aliens">0</div>
            </div>
            <div class="score-box">
                <div class="label" style="color:#ffd700">Цель</div>
                <div class="score-val" style="color:#fff">15</div>
            </div>
            <div class="score-box earth">
                <div class="label">Земляне</div>
                <div class="score-val" id="score-earth">0</div>
            </div>
        </div>
    </div>

    <button onclick="game.reset()">Начать заново</button>

    <div id="rules">
        <strong>Правила:</strong><br>
        1. Обычный ход: на соседнюю точку по линии (включая черные точки).<br>
        2. <strong>Энергетические поля (Желтые зоны):</strong> В них нельзя войти обычным шагом. Туда можно попасть <strong>только срубив врага</strong> (прыжком).<br>
        3. Попав в поле, корабль становится Тарелкой (+2 очка). Тарелка прыгает на любое расстояние.<br>
        4. Цель: набрать 15 очков.
    </div>

<script>
// КОНСТАНТЫ
const COLS = 9;
const ROWS = 7;
const CELL_SIZE_X = 85;
const CELL_SIZE_Y = 85;
const OFFSET_X = 70;
const OFFSET_Y = 65;
const RADIUS = 20;

// Определяем координаты Энергетических Полей (y, x)
// Ряд 2 (индекс 2): 4 поля
// Ряд 3 (индекс 3): 3 поля
// Ряд 4 (индекс 4): 4 поля
const ENERGY_FIELDS_COORDS = [
    // Ряд 2 (от пришельцев)
    {x: 1, y: 2}, {x: 3, y: 2}, {x: 5, y: 2}, {x: 7, y: 2},
    // Ряд 3 (центр)
    {x: 2, y: 3}, {x: 4, y: 3}, {x: 6, y: 3},
    // Ряд 4 (к землянам)
    {x: 1, y: 4}, {x: 3, y: 4}, {x: 5, y: 4}, {x: 7, y: 4}
];

const TEAM_ALIENS = 1;
const TEAM_EARTH = 2;

// Типы фишек
const T_NONE = 0;
const T_ALIEN = 1;
const T_EARTH = 2;
const T_SAUCER_ALIEN = 3;
const T_SAUCER_EARTH = 4;

class Game {
    constructor() {
        this.canvas = document.getElementById('board');
        this.ctx = this.canvas.getContext('2d');
        this.uiStatus = document.getElementById('status');
        this.uiScoreA = document.getElementById('score-aliens');
        this.uiScoreE = document.getElementById('score-earth');

        this.canvas.addEventListener('mousedown', (e) => this.handleClick(e));
        this.reset();
    }

    reset() {
        this.board = []; 
        this.scores = { [TEAM_ALIENS]: 0, [TEAM_EARTH]: 0 };
        this.turn = TEAM_ALIENS;
        this.gameOver = false;
        this.selected = null;
        this.validMoves = [];
        
        // Инициализация доски (полная сетка 7x9)
        for(let y=0; y<ROWS; y++) {
            let row = [];
            for(let x=0; x<COLS; x++) {
                // Расстановка фигур
                if (y <= 1) row.push(T_ALIEN); // Первые 2 ряда - Пришельцы
                else if (y >= 5) row.push(T_EARTH); // Последние 2 ряда - Земляне
                else row.push(T_NONE); // Пусто
            }
            this.board.push(row);
        }
        
        this.draw();
        this.updateUI();
    }

    // Проверка: является ли координата Энергетическим Полем
    isEnergyField(x, y) {
        return ENERGY_FIELDS_COORDS.some(f => f.x === x && f.y === y);
    }

    getPiece(x, y) {
        if (y < 0 || y >= ROWS || x < 0 || x >= COLS) return -1;
        return this.board[y][x];
    }

    isSaucer(p) { return p === T_SAUCER_ALIEN || p === T_SAUCER_EARTH; }

    isEnemy(p1, p2) {
        if (p1 <= 0 || p2 <= 0) return false;
        const t1 = (p1 === T_ALIEN || p1 === T_SAUCER_ALIEN) ? TEAM_ALIENS : TEAM_EARTH;
        const t2 = (p2 === T_ALIEN || p2 === T_SAUCER_ALIEN) ? TEAM_ALIENS : TEAM_EARTH;
        return t1 !== t2;
    }

    getPixel(x, y) {
        return { x: OFFSET_X + x * CELL_SIZE_X, y: OFFSET_Y + y * CELL_SIZE_Y };
    }

    getMoves(x, y) {
        let moves = [];
        const piece = this.board[y][x];
        const isS = this.isSaucer(piece);

        // Направления (8 сторон)
        const dirs = [[0,1], [0,-1], [1,0], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];

        dirs.forEach(d => {
            // --- Логика для ТАРЕЛКИ (Дальнобойная) ---
            if (isS) {
                let k = 1;
                while(true) {
                    const tx = x + d[0]*k;
                    const ty = y + d[1]*k;
                    const target = this.getPiece(tx, ty);
                    
                    if (target === -1) break; // Конец доски

                    if (target === T_NONE) {
                        // Обычный ход тарелки
                        // В поле можно войти только если ты уже в поле? Или тарелке можно?
                        // Правила: "Тарелка... теряет свойства уходя с поля". 
                        // Давайте разрешим тарелке ходить везде, но если она не рубит и не прыгает В поле - теряет силу.
                        moves.push({x: tx, y: ty, type: 'move'});
                    } else {
                        // Препятствие. Проверяем прыжок.
                        const lx = tx + d[0];
                        const ly = ty + d[1];
                        const landing = this.getPiece(lx, ly);
                        
                        if (landing === T_NONE) {
                            // Прыжок тарелки (через своих или чужих)
                            // Правило входа в поле: Только срубив врага (или перепрыгнув?).
                            // Для тарелки правило входа упрощаем: она уже мощная.
                            moves.push({
                                x: lx, y: ly, 
                                type: this.isEnemy(piece, target) ? 'capture' : 'jump',
                                kx: tx, ky: ty
                            });
                        }
                        break; // Дальше прыгать за 1 раз нельзя в этом цикле
                    }
                    k++;
                }
            } 
            // --- Логика для ОБЫЧНОГО КОРАБЛЯ ---
            else {
                const tx = x + d[0];
                const ty = y + d[1];
                const target = this.getPiece(tx, ty);

                if (target !== -1) {
                    // 1. Шаг
                    if (target === T_NONE) {
                        // ВАЖНО: Нельзя войти в Энергополе простым шагом
                        if (!this.isEnergyField(tx, ty)) {
                            moves.push({x: tx, y: ty, type: 'move'});
                        }
                    } 
                    // 2. Прыжок / Атака
                    else if (this.isEnemy(piece, target)) {
                        const lx = tx + d[0];
                        const ly = ty + d[1];
                        if (this.getPiece(lx, ly) === T_NONE) {
                            moves.push({
                                x: lx, y: ly, 
                                type: 'capture',
                                kx: tx, ky: ty
                            });
                        }
                    }
                }
            }
        });
        return moves;
    }

    handleClick(e) {
        if (this.gameOver) return;
        const rect = this.canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        // Поиск ближайшего узла
        let clickedNode = null;
        for(let y=0; y<ROWS; y++) {
            for(let x=0; x<COLS; x++) {
                const p = this.getPixel(x, y);
                const dist = Math.sqrt((mx-p.x)**2 + (my-p.y)**2);
                if (dist < 35) clickedNode = {x, y};
            }
        }

        if (!clickedNode) return;

        const pVal = this.board[clickedNode.y][clickedNode.x];
        const isOwn = (this.turn === TEAM_ALIENS && (pVal===1 || pVal===3)) ||
                      (this.turn === TEAM_EARTH && (pVal===2 || pVal===4));

        if (isOwn) {
            this.selected = clickedNode;
            this.validMoves = this.getMoves(clickedNode.x, clickedNode.y);
            this.draw();
        } else if (this.selected) {
            const move = this.validMoves.find(m => m.x === clickedNode.x && m.y === clickedNode.y);
            if (move) this.executeMove(move);
        }
    }

    executeMove(move) {
        const sx = this.selected.x;
        const sy = this.selected.y;
        let piece = this.board[sy][sx];

        this.board[sy][sx] = T_NONE;
        
        if (move.type === 'capture') {
            this.board[move.ky][move.kx] = T_NONE;
            this.scores[this.turn]++;
        }

        // Логика полей и превращений
        const inField = this.isEnergyField(move.x, move.y);
        const wasInField = this.isEnergyField(sx, sy);
        const isS = this.isSaucer(piece);

        // Вход в поле -> Становится тарелкой
        if (inField && !isS) {
            this.scores[this.turn] += 2;
            piece = (this.turn === TEAM_ALIENS) ? T_SAUCER_ALIEN : T_SAUCER_EARTH;
        }

        // Выход из поля -> Теряет силу (если не прыгает в другое поле)
        // Если тарелка уходит с поля на обычную клетку
        if (isS && wasInField && !inField) {
            piece = (this.turn === TEAM_ALIENS) ? T_ALIEN : T_EARTH;
        }

        this.board[move.y][move.x] = piece;

        if (this.scores[this.turn] >= 15) {
            this.draw();
            this.updateUI();
            setTimeout(() => alert((this.turn === 1 ? "ПРИШЕЛЬЦЫ" : "ЗЕМЛЯНЕ") + " ПОБЕДИЛИ!"), 50);
            this.gameOver = true;
            return;
        }

        this.turn = (this.turn === TEAM_ALIENS) ? TEAM_EARTH : TEAM_ALIENS;
        this.selected = null;
        this.validMoves = [];
        this.draw();
        this.updateUI();
    }

    updateUI() {
        this.uiScoreA.innerText = this.scores[TEAM_ALIENS];
        this.uiScoreE.innerText = this.scores[TEAM_EARTH];
        this.uiStatus.innerText = "ХОД: " + (this.turn === TEAM_ALIENS ? "ПРИШЕЛЬЦЫ" : "ЗЕМЛЯНЕ");
        this.uiStatus.style.background = this.turn === TEAM_ALIENS ? "rgba(255, 42, 42, 0.2)" : "rgba(0, 234, 255, 0.2)";
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // 1. РИСУЕМ СЕТКУ (Линии)
        this.ctx.lineWidth = 2;
        this.ctx.strokeStyle = "#2c2c45";
        for(let y=0; y<ROWS; y++) {
            for(let x=0; x<COLS; x++) {
                const p1 = this.getPixel(x, y);
                const neighbors = [[1,0], [0,1], [1,1], [-1,1]];
                
                neighbors.forEach(d => {
                    const nx = x + d[0];
                    const ny = y + d[1];
                    if (this.getPiece(nx, ny) !== -1) {
                        const p2 = this.getPixel(nx, ny);
                        this.ctx.beginPath();
                        this.ctx.moveTo(p1.x, p1.y);
                        this.ctx.lineTo(p2.x, p2.y);
                        this.ctx.stroke();
                    }
                });
            }
        }

        // 2. ЭНЕРГЕТИЧЕСКИЕ ПОЛЯ (Подложка)
        ENERGY_FIELDS_COORDS.forEach(f => {
            const p = this.getPixel(f.x, f.y);
            
            // Свечение
            const grad = this.ctx.createRadialGradient(p.x, p.y, 10, p.x, p.y, 55);
            grad.addColorStop(0, "rgba(255, 200, 0, 0.2)");
            grad.addColorStop(1, "rgba(255, 200, 0, 0)");
            this.ctx.fillStyle = grad;
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, 60, 0, Math.PI*2);
            this.ctx.fill();

            // Контур поля
            this.ctx.strokeStyle = "#d4af37";
            this.ctx.lineWidth = 1.5;
            this.ctx.setLineDash([5, 5]);
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, 40, 0, Math.PI*2);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
        });

        // 3. УЗЛЫ (Черные точки) и ФИШКИ
        for(let y=0; y<ROWS; y++) {
            for(let x=0; x<COLS; x++) {
                const p = this.getPixel(x, y);
                
                // Если это Энергополе, рисуем желтый центр, иначе черный
                if (this.isEnergyField(x, y)) {
                    this.ctx.fillStyle = "#d4af37";
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, 5, 0, Math.PI*2);
                    this.ctx.fill();
                } else {
                    this.ctx.fillStyle = "#111"; // Обычный узел
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
                    this.ctx.fill();
                    this.ctx.strokeStyle = "#333";
                    this.ctx.stroke();
                }

                const val = this.board[y][x];
                if (val !== T_NONE) {
                    this.drawPiece(p.x, p.y, val, (this.selected && this.selected.x===x && this.selected.y===y));
                }
            }
        }

        // 4. ПОДСВЕТКА ХОДОВ
        this.validMoves.forEach(m => {
            const p = this.getPixel(m.x, m.y);
            this.ctx.fillStyle = (m.type === 'capture') ? "rgba(255, 50, 50, 0.6)" : "rgba(50, 255, 50, 0.4)";
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, 12, 0, Math.PI*2);
            this.ctx.fill();
        });
    }

    drawPiece(x, y, type, isSelected) {
        const color = (type === T_ALIEN || type === T_SAUCER_ALIEN) ? "#ff2a2a" : "#00eaff";
        const isSaucer = (type === T_SAUCER_ALIEN || type === T_SAUCER_EARTH);

        if (isSelected) {
            this.ctx.shadowBlur = 20;
            this.ctx.shadowColor = color;
        }

        this.ctx.fillStyle = "#1a1a2e";
        this.ctx.lineWidth = 3;
        this.ctx.strokeStyle = color;
        
        this.ctx.beginPath();
        if (isSaucer) {
            this.ctx.arc(x, y, RADIUS, 0, Math.PI*2);
            this.ctx.fill();
            this.ctx.stroke();
            
            this.ctx.fillStyle = color;
            this.ctx.beginPath();
            this.ctx.arc(x, y, RADIUS * 0.5, 0, Math.PI*2);
            this.ctx.fill();
            
            this.ctx.fillStyle = "#fff";
            this.ctx.font = "14px Arial";
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            this.ctx.fillText("★", x, y);
        } else {
            const dir = (type === T_ALIEN) ? 1 : -1;
            this.ctx.beginPath();
            this.ctx.moveTo(x, y + (RADIUS * dir));
            this.ctx.lineTo(x - (RADIUS * 0.8), y - (RADIUS * 0.6 * dir));
            this.ctx.lineTo(x + (RADIUS * 0.8), y - (RADIUS * 0.6 * dir));
            this.ctx.closePath();
            this.ctx.fill();
            this.ctx.stroke();
            
            this.ctx.fillStyle = color;
            this.ctx.beginPath();
            this.ctx.arc(x, y, 4, 0, Math.PI*2);
            this.ctx.fill();
        }
        this.ctx.shadowBlur = 0;
    }
}

const game = new Game();
</script>
</body>
</html>
